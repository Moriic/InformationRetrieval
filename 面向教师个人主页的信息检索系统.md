# 面向教师个人主页的信息检索系统

## 词项

使用开源的中文分词程序（如结巴分词）把中文句子或 query 转换成 terms，使用开源的英文词干提取算法（如 Porter algorithm）对英文句子或 query 进行处理，需要详细说明如何在程序中导入相关软件包、如何在程序中调用相关函数，以及如何进行相关配置和修改等。

### 中文分词

##### 结巴分词支持三种分词模式

- **精确模式**：试图将句子最精确地切分，适合文本分析。

- **全模式**：把句子中所有可能的词语都扫描出来，速度非常快，但不能解决歧义。

- **搜索引擎模式**：在精确模式的基础上，对长词再进行一次切分，提高召回率，适合用于搜索引擎分词。

> **这里使用搜索引擎模式，以更好地检索文档。**

#### 引入 Maven 依赖

中文分词使用结巴分词，由于使用的是 Java，需要使用 Maven 引入结巴分词的依赖

![image-20240804022332909](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709413_0.png)

#### 封装中文分词工具类

- 创建结巴分词实例 JiebaSegmenter segmenter = new JiebaSegmenter();

- 对于传入的 text，使用正则表达式获取中文句子，并 **调用 segmenter.process(zhText, JiebaSegmenter.SegMode.SEARCH) 进行搜索引擎模式的分词并返回**

![image-20240804022354220](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709434_0.png)

### 英文分词（Apache Lucene）

#### 介绍

**Apache Lucene** 是一个高性能的全文搜索库，广泛用于各种信息检索和搜索引擎应用。为了提高搜索的效果，Lucene 使用了多种分词技术，其中之一是 Porter Stemming Algorithm。Porter 算法是一种用于 **英语词干提取** 的算法，它通过去掉单词的词缀（如 "-ing", "-ed"）来找到单词的 **词根**，从而提高搜索匹配的准确性

#### 引入 Maven 依赖

![image-20240804022401738](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709442_0.png)

#### 封装英文分词工具类

- 对于传入的 text，使用正则表达式去除中文字符，

- 调用 enTokenize，用 非字符 进行分词，分词后每个单词开头的大写会变小写

- 调用 enWordStem 进行词干提取，最终返回分词结果

![image-20240804022409902](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709450_0.png)

### 封装分词工具类

**对中文句子使用结巴分词，英文句子使用 Apache Lucene 进行分词，** 最终合并分词结果

![image-20240804022417720](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709458_0.png)

### 测试分词工具

![image-20240804022423805](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709464_0.png)

> **可见对于中文和英文都进行了合理地分词。**

## 交互

##### 开发的信息检索系统要求支持较为友好的用户交互，包括输入框（至少支持中英文两种语言的 query）和返回结果的呈现（包含超链接跳转），界面简洁美观。

![image-20240804022428830](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709469_0.png)

系统界面如上图所示，实现的功能包括：

- 由于我们实现了中英文的分词工具，搜索框同时可以支持中英文的 query

- 支持三种搜索类型：相似度搜索，邻近搜索，通配符搜索

- 支持四个搜索域：全部，姓名，个人简历，研究领域

- 支持图片和文档预览，支持点击 “查看原始页面” 后跳转到原页面

- 接入大模型，实现语音搜索，query 纠错

## **索引**

要求使用倒排索引（inverted index）, 不能使用数据库中的关系表来存储数据，并分析倒排索引构建的时间复杂度。**

### 建立 positional index

为了实现后面实现临近搜索，我们建立 **positional index**，他比倒排索引增加了位置信息。

存储的数据结构为两层 TreeMap，外层 Map 用来存储 term 和 docId 的映射关系，内层 Map 用来存储 docID 和 posList 的映射关系，如下图所示：

![image-20240804022435875](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709476_0.png)

**读取流程：**

- 读取文件的每一行，将该行的字符串进行结巴分词

- 遍历每一个单词，使用 pos 标记该单词的位置

- 当该单词不存在时，则插入一个新的 Map 表，并将位置信息插入内存 Map 中

- 单词存在时，则取出内层 Map 表，并将新的 pos 加入到 posList 中

![image-20240804022439606](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709480_0.png)

### 时间复杂度分析

使用了一层循环，循环内的 HashMap 操作复杂度为 O(logN)，因此总的时间复杂度为 O(NlogN)，N 为 token 的数量。

## **权重**

**要求使用 TF-IDF 作为权重的计算方式，在报告中包含相关的数学公式。要求使用公式编辑工具，不能截图，并对公式中的符号做出解释，对相关的代码实现给出详细的注释，并分析该部分的时间复杂度。**

### 遍历文档集获取 term 集合

使用集合 TreeSet 存储：

![image-20240804022452671](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709493_0.png)

遍历文档集使用自定义分词工具进行分词，并将 token 加入 terms 集合中

![image-20240804022502979](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709503_0.png)

### 获取 df

**df，即每个词项在文档集中的出现次数，每个文档中只记一次**，使用下面数据结构进行存储，外层 HashMap 的 key 为 term，value 为一个集合 Set，用来存储当前 term 下的 docId 的集合，最终 **集合的大小 size 即为 term 在文档集中的出现次数，并且每个 docId 只记一次（使用 set 去重了）**

![image-20240804022525534](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709525_0.png)

在遍历的时候不断地将当前 docId 加入 token 对应的集合中即可

![image-20240804022508862](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709509_0.png)

### 获取 idf

有了 df 后，根据公式得到 idf：

$\text{idf}_{t} = \log_{10}\left( \frac{N}{\text{df}_{t}} \right)$

**符号解释：(N：文档集个数，** $\text{df}_{t}$ **：t 在文档集中的出现次数）**

![image-20240804022549036](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709549_0.png)

### 获取 tf

**首先需要统计每个 term 在每条文档中的出现次数**，我们使用下面数据结构进行存储，外层 HashMap 的 key 为 term，内层 HashMap 的 key 为 docId，value 为 term 的出现次数，表示当前 term 在当前 docId 下的出现次数。

![image-20240804022601222](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709561_0.png)

在遍历的时候不断将当前 token 对应的 docId 的数量加一即可

![image-20240804022558687](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709559_0.png)

根据公式计算 tf：

$$w_{t, d} = \left\{ \begin{matrix}
1 + \log_{10}tf_{t, d} & \text{if }tf_{t, d} > 0 \\
0 & \text{otherwise}
\end{matrix} \right.\ $$

**符号解释：** $\mathbf{t}\mathbf{f}_{\mathbf{t,d}}$ **表示 t 在文档 d 中出现的次数**

![image-20240804022610228](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709570_0.png)

### 计算 tf-idf

> 根据 tf-idf 的计算公式：

$$w_{t,d} = (1 + \log\text{tf}_{t,d}) \cdot \log\left( \frac{N}{\text{df}_{t}} \right)$$

> 首先我们使用数据结构二维数组存储 tf-idf 向量，

![image-20240804022620769](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709581_0.png)

遍历每个 doc，对每个 docId，遍历 term，并计算 tf-idf，然后加入结果集中：

![image-20240804022625158](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709585_0.png)

输出 tf-idf 矢量，发现存在大量的 0，这是由于很多的 term 在当前 doc 中并不存在，值为 0

![image-20240804022630360](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709590_0.png)

使用数据结构 Map 数组来优化存储方式，key 为 term，value 为 tf_idf

![image-20240804022635182](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709595_0.png)

并且此时我们只需要遍历每个 doc 中的 token 即可，不在当前 doc 中的 term 的 tf_idf 的值为 0

![image-20240804022657695](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709618_0.png)

输出 tf-idf，只存储了有值的，不仅节省了空间，还加快了计算速度

![image-20240804022647581](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709608_0.png)

### 时间复杂度分析

与 positional Index 类似，使用了一层循环，循环内的 HashMap 操作复杂度为 O(logN)，因此总的时间复杂度也为 O(NlogN)，N 为 token 的数量。

## 相关性：

要求使用余弦相似度作为 \< query, document \> 的相关性分值的计算方式，在报告中包含相关的数学公式。要求使用公式编辑工具，不能截图，并对公式中的符号做出解释，对相关的代码实现给出详细的注释（如在实现中做了某种简化或修改需要明确说明），并分析该部分的时间复杂度。

### 计算余弦相似度

根据公式：

$$\cos(\overrightarrow{q},\overrightarrow{d}) = \text{SIM}(\overrightarrow{q},\overrightarrow{d}) = \frac{\overrightarrow{q} \cdot \overrightarrow{d}}{|\overrightarrow{q}||\overrightarrow{d}|} = \frac{\sum_{i = 1}^{\mathcal{|V|}}q_{i}d_{i}}{\sqrt{\sum_{i = 1}^{\mathcal{|V|}}q_{i}^{2}}\sqrt{\sum_{i = 1}^{\mathcal{|V|}}d_{i}^{2}}}$$

**公式解释：** $\overrightarrow{\mathbf{q}}$ **表示 query 的 tf-idf 向量，** $\overrightarrow{\mathbf{d}}$ **表示 document 的 tf-idf 向量**

### 计算两个向量的余弦值

首先封装工具类 CalculateUtil 用来计算两个向量的余弦值，其中向量使用 HashMap 存储：

![image-20240804022756695](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709677_0.png)

### 计算 query 和 document 的相似度

- 为了加快 query 的速度，我们在项目启动时就将每个 document 的 TF-IDF 向量计算好

- 在搜索时我们只需要使用相同的分词工具，计算 query 的 TF-IDF 向量获取 document 的向量后调用工具类进行两个向量的余弦值计算

![image-20240804022801453](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709681_0.png)

## 排序

要求根据相关性分值的大小对匹配到的 documents 进行排序，返回 top 10 的结果（要求同时显示每个返回的 document 的相关性的分值信息）。需要特别注意效率问题，要求在查询结果的上方显示查询的耗时（单位秒，保留小数点后两位）。

### 获取相似度最高的五个文档

为了获取相似度最高的文档，我们将每次计算的结果加入优先队列中

![image-20240804022806983](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709687_0.png)自定义排序方式：先按相似度排序，再按文档 id 排序

![image-20240804022810818](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709691_0.png)

### 耗时显示

记录开始和结束的时间，并计算差值返回前端

![image-20240804022815680](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709696_0.png)

### 测试结果

![image-20240804022821680](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709702_0.png)

## 大模型

要求使用百度文心一言大模型 API、阿里通义千问大模型 API、腾讯混元大模型 API、月之暗面 Kimi 大模型 API 或其他大模型 API 中的一个 API，并实现某一功能（例如，在返回的结果中同时呈现大模型的返回结果和从倒排索引返回的结果）。

使用大模型智谱 AI <https://open.bigmodel.cn/>，对获取的文档进行问答，例如可以查看某位老师的个人信息。

### 构建知识库

首先将爬取的文档上传到知识库中，共有 244 个文档。

![image-20240804022828962](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709709_0.png)

### 调用 API 进行问答

根据接口：<https://open.bigmodel.cn/dev/howuse/retrieval>，参数主要包含问题 question，类型 Retrieval 检索，知识库 ID

![image-20240804022835319](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709715_0.png)

### 返回结果显示

这里以张晓平老师为例，并且支持 **流式显示，即实时显示，** 后面会说明：

![image-20240804022839704](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709720_0.png)

## 邻近搜索

支持基于 positional index 的邻近搜索（proximity search）。

之前我们已经构建了 positional index，下面实现邻近搜索：**搜索格式为 (token1, token2, k)**

### 根据输入获取左右距离 left, right

- 对于 **“-x”，** 两个单词位置距离 pos1 - pos2 在 \[-x, 0\]之间

- 对于 **“+x”，** 距离在 \[0, x\] 之间

- 对于 **“x”，** 距离在 \[-x, x\] 之间

  ![image-20240804022848599](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709729_0.png)

### 使用两个指针 p1, p2 遍历两个 term 的 docId 集合

- 若 docId1 = docId2，则进行内层循环

- 若不等于，docId 小的指针向后移动

  ![image-20240804022853622](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709734_0.png)

> 当两个 docId 相等时，使用两个指针 pp1, pp2 遍历两个文档 id 对应的 posList，若两个位置距离在指定范围内 \[left, right\]，即 pos1 - pos2 \>= left && pos1 - pos2 \<= right，则将结果加入结果集

![image-20240804022900727](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709741_0.png)

对于三种情况，都是判断两个位置距离在指定范围内 \[left, right\]，即 pos1 - pos2 \>= left && pos1 - pos2 \<= right

### 测试结果

![image-20240804022906675](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709747_0.png)

## 支持通配符查询（wildcard query）。

### 数据结构

使用字典树进行存储，也就是一棵 B 树，每个节点包含一个子节点数组 children(表示下一个字符)和一个标记 isEndOfWord(表示该节点是否为结束节点)

![image-20240804022912047](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709752_0.png)

### 插入操作

- 为了支持通配符查找，在插入字典时，我们需要插入其所有的变体，如插入 hello 时，我们要同时插入 hello\$, ello\$h, llo\$he, lo\$hel, o\$hell,\$hello，同时我们需要使用一个 Map 存储这些字典与 hello 的映射关系。


![image-20240804022916474](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709756_0.png)

- 插入一个单词时，只需要遍历每一个字符，若当前节点的子节点数组中该字符不存在，则创建一个新节点，并且标记最后一个字符节点为结束字符


![image-20240804022920795](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709761_0.png)

例如：hello 的所有变体插入后如图所示

![image-20240804022925426](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709765_0.png)

### 查找以指定前缀开头的所有单词

在查找通配符单词前先实现一个 getWordsWithPrefix 函数用来查找以指定前缀开头的所有单词

- 首先定位到包含该前缀的节点

- 接着以该节点为节点进行 **递归操作** 获得以该前缀开头的所有单词

- 当节点的标记为 **isEndOfWord** 时，说明为字典单词，将其通过 **映射表 Map** 获取原单词后加入到结果集


![image-20240804022933364](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709773_0.png)

![image-20240804022937111](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709777_0.png)

### 判断单词是否在字典树中

getWordWithEqual 用来判断单词是否在字典树中：

- 遍历字典树直到与单词相等的节点，若有字符不存在字典树中，则返回空数组

- 遍历到节点后，若节点标记为 isEndOfWord，说明单词存在字典树，否则不存在

![image-20240804022952672](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709793_0.png)

### 通配符查找

之前我们已经将字典的所有变体插入到字典树，并实现了查找指定前缀的单词和判断单词是否在字典树中的函数，此时通配符查找存在以下情况：

- 对于查找 X ：查找 X\$ 或者 \$X，即 getWordWithEqual(X\$)

- 对于查找 X\*: 查找 \$X\*，即 getWordsWithPrefix(\$X)

- 对于查找 \*X: 查找 X\$\*，即 getWordsWithPrefix(X\$)

- 对于查找 X\*Y: 查找 Y\$X\*，即 getWordsWithPrefix(Y\$X)

- 对于查找 \*X\*: 查找 X\*，即 getWordsWithPrefix(X)

![image-20240804022958854](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709799_0.png)

### 测试结果

**查询含以清华开头的文档 清华\*：**

![image-20240804023007768](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709808_0.png)

## 支持个人主页中的图片、附件等内容的展示。

**支持预览个人主页的图片，并分五个标签显示信息：个人简历、教学、研究领域、研究成果、奖励荣誉，并支持超链接跳转，** 如下图所示：

![image-20240804023017712](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709818_0.png)

## 支持按域检索

要求包含 4 个不同的“域”: “全部”、“姓名”、“个人简历”、“研究领域”等。

在爬虫时，我们将每个域分隔开，因此只需要在构建文档数据时只读取该域进行处理即可，其余一致，这里支持四个不同的“域”： “全部”、“姓名”、“个人简历”、“研究领域”：

![image-20240804023022362](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709822_0.png)

**全部域：**

![image-20240804023026857](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709827_0.png)

**姓名域：**

![image-20240804023031619](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709832_0.png)

## 支持友好的用户交互

例如，通过字体标红或黄色阴影等方式帮助用户快速理解返回的结果。

### **支持标红字体：**

![image-20240804023037871](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709838_0.png)

## 倒排记录表

优化倒排记录表（postings list）存储的空间复杂度。

对 positional Index 进行压缩，使用 gap 间隔进行存储并使用 VB 编码降低存储空间。

### VB 编码过程

- 使用循环对输入的数字进行编码，直到数字为 0。

- 在循环中，计算数字除以 128 的余数，取得余数的低 7 位作为当前字节。

- 如果余数小于 128，则将该余数作为一个字节添加到 output 列表的最前面，并结束循环。

- 如果余数大于等于 128，则将该余数的最高位设置为 1 表示后续还有数据，然后将该字节添加到 output 列表的最前面。

- 将数字除以 128，准备下一轮计算。


![image-20240804023045295](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709845_0.png)

### VB 解码过程

- 遍历输入的字节数组列表。

- 对于每个字节数组，检查其最高位，如果最高位为 0，则表示这是最后一个字节；如果最高位为 1，则表示后续还有数据，需要将最高位去除，即减去 128。

- 计算 number = number \* 128 + byteArr

- 最终返回 number 转换为整数类型的结果。

![image-20240804023053749](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709854_0.png)

## query 纠错

支持 query 建议或 query 纠错（方法不限于教材中的方法），能够给出 1-3 个合理/正确的候选 query。

**使用讯飞大模型对文本进行纠错：** <https://www.xfyun.cn/doc/nlp/textCorrection/API.html#%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E>

大模型会将各种错误结果返回，这里我们选取三种错误：别字纠错，别词纠错，成语纠错，并将三种结果纠错后和组合纠错后的文本放入集合中返回。

![image-20240804023058771](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709859_0.png)

### 测试结果

对文本“**青华大学叫收深杜学习**”进行纠错后给出三个建议，其中最符合的是“**清华大学教授深度学习**”，结果很正确，点击后即可重新搜索

![image-20240804023104289](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709864_0.png)

## 语音输入

### 使用讯飞大模型的语音识别功能

API 接口：<https://www.xfyun.cn/doc/asr/voicedictation/API.html#%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E>

调用过程主要涉及前端的引入，XfVoiceDictation，接着调用 API 将语音识别结果显示到搜索框中即可。

![image-20240804023109826](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709870_0.png)

### 测试结果

![image-20240804023117309](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709877_0.png)

使用程序爬取数据，并按域分隔，“个人简历”、“教学”、“研究领域”、“研究成果”、“奖励荣誉”，以支持 Tab 栏的展示以及按域搜索。

为了保持文档的格式一致性，本次实验使用爬虫的形式从清华大学的官网中获取数据，共有 244 个文档，并按一定格式存储，如下图：

![image-20240804023122585](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709883_0.png)

有了规范的格式，后面对文档进行搜索时可以按域搜索，并支持五个 Tab 栏进行展示

![image-20240804023129279](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709889_0.png)

在调用智谱大模型时，支持流式问答(即实时显示结果)和多轮问答

![image-20240804023136201](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709896_0.png)

### SSE 协议

> ##### 流式问答利用了 SSE 协议，支持服务器先客户端实时发送信息
>

后端流式发送消息

![](media/image59.png)

前端连接后 onmessage 获取信息，回答结束则关闭。

![](media/image60.png)

## 最终效果

![image-20240804023155949](https://raw.githubusercontent.com/Moriic/picture/main/image/1722709916_0.png)
